using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading;
using System.Threading.Tasks;

namespace Molten.Graphics
{
    public class HlslShader : HlslFoundation, IShader
    {
        // TODO move these to back to the HLSL compiler via a metadata system.
        internal string DefaultVSEntryPoint;
        internal string DefaultGSEntryPoint;
        internal string DefaultDSEntryPoint;
        internal string DefaultHSEntryPoint;
        internal string DefaultPSEntryPoint;

        internal RWVariable[] UAVs = new RWVariable[0];
        internal ShaderConstantBuffer[] ConstBuffers = new ShaderConstantBuffer[0];
        internal ShaderResourceVariable[] Resources = new ShaderResourceVariable[0];
        internal ShaderSamplerVariable[] SamplerVariables = new ShaderSamplerVariable[0];
        internal Dictionary<string, IShaderValue> Variables = new Dictionary<string, IShaderValue>();
        
        internal IShaderResource[] DefaultResources;

        DeviceDX11 _device;
        string _filename;
        internal ShaderIOStructure InputStructure;
        Dictionary<string, string> _metadata;

        public string Description { get; internal set; }

        public string Author { get; internal set; }
        
        public string Filename => _filename;

        Dictionary<string, HlslPass> _passesByName;

        public int PassCount => Passes.Length;

        public Dictionary<string, string> Metadata => _metadata;

        static int _nextSortKey;

        internal HlslPass[] Passes = new HlslPass[0];
        internal byte[] InputStructureByteCode;

        internal HlslShader(DeviceDX11 device, string filename = null) : base(device)
        {
            SortKey = Interlocked.Increment(ref _nextSortKey);
            _filename = filename ?? "";
            _device = device;
            _metadata = new Dictionary<string, string>();
            _passesByName = new Dictionary<string, HlslPass>();
        }

        public override string ToString()
        {
            return $"{this.GetType().Name} shader -- {Name}";
        }

        public void SetDefaultResource(IShaderResource resource, int slot)
        {
            if (slot >= DefaultResources.Length)
                throw new IndexOutOfRangeException($"The highest slot number must be less-or-equal to the highest slot number used in the shader source code ({DefaultResources.Length}).");

            Array.Resize(ref DefaultResources, slot + 1);
            DefaultResources[slot] = resource;
        }

        public IShaderResource GetDefaultResource(int slot)
        {
            if (slot >= DefaultResources.Length)
                throw new IndexOutOfRangeException($"The highest slot number must be less-or-equal to the highest slot number used in the shader source code ({DefaultResources.Length}).");
            else
                return DefaultResources[slot];
        }

        /// <summary>
        /// Creates a new pass using the default shader stage entry points.
        /// </summary>
        internal void AddDefaultPass()
        {
            // TODO move this back to the HLSL compiler via a metadata system.
            HlslPass defaultPass = new HlslPass(this)
            {
                Name = "<Auto-generated pass>",
            };
            defaultPass.VertexShader.EntryPoint = DefaultVSEntryPoint;
            defaultPass.GeometryShader.EntryPoint = DefaultGSEntryPoint;
            defaultPass.DomainShader.EntryPoint = DefaultDSEntryPoint;
            defaultPass.HullShader.EntryPoint = DefaultHSEntryPoint;
            defaultPass.PixelShader.EntryPoint = DefaultPSEntryPoint;
            AddPass(defaultPass);
        }

        internal void AddPass(HlslPass pass)
        {
            int id = 0;
            if (Passes == null)
            {
                Passes = new HlslPass[1];
            }
            else
            {
                id = Passes.Length;
                Array.Resize(ref Passes, Passes.Length + 1);
            }

            Passes[id] = pass;
        }

        public IShaderPass GetPass(int index)
        {
            return Passes[index];
        }

        public IShaderPass GetPass(string name)
        {
            return _passesByName[name];
        }

        public ObjectMaterialProperties Object { get; set; }

        public LightMaterialProperties Light { get; set; }

        public SceneMaterialProperties Scene { get; set; }

        public GBufferTextureProperties Textures { get; set; }

        public SpriteBatchMaterialProperties SpriteBatch { get; set; }

        /// <summary>Gets or sets the value of a material parameter.</summary>
        /// <value>
        /// The <see cref="System.Object"/>.
        /// </value>
        /// <param name="varName">The varialbe name.</param>
        /// <returns></returns>
        public IShaderValue this[string varName]
        {
            set
            {
                //if the shader is invalid, skip applying data
                //if (!_isValid)
                //    return;

                IShaderValue varInstance = null;

                if (Variables.TryGetValue(varName, out varInstance))
                    varInstance.Value = value;
            }

            get
            {
                //if the shader is invalid, skip applying data
                //if (!_isValid)
                //    return null;

                IShaderValue varInstance = null;

                if (Variables.TryGetValue(varName, out varInstance))
                    return varInstance;
                else
                    return null;
            }
        }

        /// <summary>
        /// Gets the sort key assigned to the current shader.
        /// </summary>
        public int SortKey { get; }
    }
}
